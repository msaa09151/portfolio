<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ë„¤ëª¨ë„¤ëª¨ ë¡œì§ (10Ã—10) â€” Demo</title>
<style>
  /* ì „ì²´ ìŠ¤íƒ€ì¼: ë°°ê²½ ê²€ì •, ì„ (ë° í™œì„±ì„ ) í°ìƒ‰, ëª¨ë“  ì„  êµµê¸° ë™ì¼ */
  :root{
    --bg:#000;
    --line:#fff;
    --line-alpha:rgba(255,255,255,0.14); /* ë¹„í™œì„± ê·¸ë¦¬ë“œ ì„ (í¬ë¯¸í•˜ê²Œ) */
    --stroke:4; /* ëª¨ë“  ì„  êµµê¸° (px) - ë™ì¼í•˜ê²Œ ìœ ì§€) */
    --dot-radius:4;
    --canvas-pad:18px;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,system-ui,Apple SD Gothic Neo,'Malgun Gothic',sans-serif}
  .wrap{max-width:980px;margin:24px auto;padding:18px}
  h1{margin:0 0 12px 0;font-size:20px}
  p {margin:6px 0;color:rgba(255,255,255,0.8)}
  .toolbar{display:flex;gap:10px;align-items:center;margin-bottom:12px}
  button{background:transparent;border:1px solid rgba(255,255,255,0.14);color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.primary{background:var(--line);color:#000;border-color:var(--line)}
  button.warn{border-color:#ff6b6b}
  .status{margin-left:12px;font-size:14px;color:var(--line-alpha)}
  /* ë³´ë“œ ì»¨í…Œì´ë„ˆ ì¤‘ì•™ ì •ë ¬ */
  .board-wrap{display:flex;justify-content:center;align-items:center;padding:10px 0}
  /* SVGëŠ” ë°˜ì‘í˜• */
  svg{max-width:100%;height:auto;display:block;border-radius:8px}
  /* ì„¤ëª… í…ìŠ¤íŠ¸ */
  .help{margin-top:10px;color:var(--line-alpha);font-size:13px}
  /* ëª¨ë°”ì¼ìš© ì•½ê°„ì˜ ì—¬ë°± */
  @media (max-width:520px){ .wrap{padding:10px} h1{font-size:18px} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>ë„¤ëª¨ë„¤ëª¨ ë¡œì§ (10 Ã— 10)</h1>
    <p>í´ë¦­ ë˜ëŠ” ë“œë˜ê·¸ë¡œ ì„ ì„ ê·¸ë ¤ì„œ í•˜ë‚˜ì˜ ë‹«íŒ ë£¨í”„(ë¶„ê¸°/ëŠê¹€ ì—†ìŒ)ë¥¼ ë§Œë“œì„¸ìš”. <strong>ëª¨ë“  ì„  êµµê¸°ëŠ” ë™ì¼</strong>í•©ë‹ˆë‹¤.</p>

    <div class="toolbar">
      <button id="checkBtn" class="primary">ì •ë‹µ í™•ì¸</button>
      <button id="newBtn">ìƒˆ ê²Œì„</button>
      <button id="clearBtn">ì§€ìš°ê¸°</button>
      <div class="status" id="status">ìƒíƒœ: ì¤€ë¹„</div>
    </div>

    <div class="board-wrap">
      <!-- SVG ë³´ë“œ: ì ì€ (N+1)x(N+1), ì…€ì€ N x N -->
      <svg id="board" viewBox="0 0 520 520" width="520" height="520" aria-label="ë„¤ëª¨ë„¤ëª¨ ë³´ë“œ" role="img"></svg>
    </div>

    <div class="help">
      <div>- í´ë¦­: ê°œë³„ ì—£ì§€ í† ê¸€</div>
      <div>- í´ë¦­ í›„ ë“œë˜ê·¸: ì—¬ëŸ¬ ì—£ì§€ë¥¼ ì—°ì†ìœ¼ë¡œ ê·¸ë¦¬ê±°ë‚˜ ì§€ìš¸ ìˆ˜ ìˆìŒ</div>
      <div>- ì •ë‹µ í™•ì¸: í˜„ì¬ ê·¸ë¦° ì„ ì´ <strong>ë‹¨ì¼ íë£¨í”„(ëª¨ë‘ ì—°ê²°ëœ í•˜ë‚˜ì˜ ì‚¬ì´í´)</strong>ì¸ì§€ ê²€ì‚¬</div>
      <div>- ìƒˆ ê²Œì„: ê°„ë‹¨í•œ ëœë¤ ë£¨í”„(ì‚¬ê°í˜• ë“±)ë¥¼ ì •ë‹µìœ¼ë¡œ ì„¤ì •í•˜ê³  ë³´ë“œ ì´ˆê¸°í™”</div>
    </div>
  </div>

<script>
/*
  ë„¤ëª¨ë„¤ëª¨ ë¡œì§ (10x10) â€” ê°„ë‹¨ êµ¬í˜„
  - ê²©ì: N x N ì…€ (N=10)
  - ì (ì •ì )ì€ (N+1)x(N+1)
  - ì—£ì§€(edge)ëŠ” ì ë“¤ ì‚¬ì´ì˜ ìˆ˜í‰(h) ë˜ëŠ” ìˆ˜ì§(v) ê°„ì„ 
  - ì‚¬ìš©ìëŠ” ì—£ì§€ë¥¼ í´ë¦­/ë“œë˜ê·¸í•˜ì—¬ í™œì„±í™”(ì„ ) ë˜ëŠ” ë¹„í™œì„±í™”(ì—†ìŒ) ê°€ëŠ¥
  - "ì •ë‹µ í™•ì¸" : í™œì„± ì—£ì§€ê°€ í•˜ë‚˜ì˜ íë£¨í”„(single cycle)ì¸ì§€ ê²€ì‚¬
  - "ìƒˆ ê²Œì„" : ê°„ë‹¨í•œ ëœë¤ ë£¨í”„ë¥¼ ìƒì„±(ì •ë‹µìœ¼ë¡œ ì„¤ì •)í•˜ê³  ë³´ë“œë¥¼ ì´ˆê¸°í™”
*/

// ì„¤ì •
const N = 10;                     // ì…€ ìˆ˜
const SIZE = 520;                 // SVG viewBox ì •ì‚¬ì´ì¦ˆ
const PAD = 28;                   // ë‚´ë¶€ íŒ¨ë”©
const strokeW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--stroke')) || 4;
const dotRadius = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dot-radius')) || 4;

const svg = document.getElementById('board');
const statusEl = document.getElementById('status');
const checkBtn = document.getElementById('checkBtn');
const newBtn = document.getElementById('newBtn');
const clearBtn = document.getElementById('clearBtn');

const gridW = SIZE - PAD*2;
const cell = gridW / N; // í•œ ì…€ í¬ê¸°

// ë‚´ë¶€ ë°ì´í„° êµ¬ì¡°
// edges: í‚¤ -> SVG element, state.active -> boolean
// key format: 'h_r_c' (horizontal edge at row r, col c) between dot (r,c) and (r,c+1)
//             'v_r_c' (vertical edge at row r, col c) between dot (r,c) and (r+1,c)
const edges = {}; // map key -> {el, active}

// ì •ë‹µ(ì†”ë£¨ì…˜)ë„ ê°™ì€ í‚¤ì˜ ì§‘í•©ìœ¼ë¡œ ì €ì¥ (ìƒˆ ê²Œì„ ìƒì„±ì‹œ ë³€ê²½)
let solutionSet = new Set();

// ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ìƒíƒœ
let isMouseDown = false;
let drawMode = null; // 'on' or 'off' or null
let lastToggled = null; // ê°™ì€ ì—£ì§€ ì—¬ëŸ¬ë²ˆ í† ê¸€ ë°©ì§€

// SVG namespace
const SVG_NS = "http://www.w3.org/2000/svg";

// ì´ˆê¸°í™”: SVG ìš”ì†Œ ìƒì„±
function buildBoard(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);

  // ë°°ê²½ rect (ê²€ì • ìœ ì§€)
  const bg = document.createElementNS(SVG_NS,'rect');
  bg.setAttribute('x',0);
  bg.setAttribute('y',0);
  bg.setAttribute('width',SIZE);
  bg.setAttribute('height',SIZE);
  bg.setAttribute('fill','black');
  svg.appendChild(bg);

  // ê·¸ë£¹: ê·¸ë¦¬ë“œ(ë¹„í™œì„± ì„ , í¬ë¯¸)
  const gridGroup = document.createElementNS(SVG_NS,'g');
  gridGroup.setAttribute('stroke','rgba(255,255,255,0.14)');
  gridGroup.setAttribute('stroke-width', strokeW);
  gridGroup.setAttribute('stroke-linecap','round');
  gridGroup.setAttribute('fill','none');
  svg.appendChild(gridGroup);

  // ì  ì¢Œí‘œ ë°°ì—´
  function dotX(col){ return PAD + col * cell; }
  function dotY(row){ return PAD + row * cell; }

  // ë¹„í™œì„± ê·¸ë¦¬ë“œ ì„ (ì „ì²´)
  // ìˆ˜í‰ì„ 
  for(let r=0;r<=N;r++){
    for(let c=0;c<N;c++){
      const x1 = dotX(c), y1=dotY(r);
      const x2 = dotX(c+1), y2=dotY(r);
      const line = document.createElementNS(SVG_NS,'line');
      line.setAttribute('x1',x1); line.setAttribute('y1',y1);
      line.setAttribute('x2',x2); line.setAttribute('y2',y2);
      gridGroup.appendChild(line);
    }
  }
  // ìˆ˜ì§ì„ 
  for(let c=0;c<=N;c++){
    for(let r=0;r<N;r++){
      const x1 = dotX(c), y1=dotY(r);
      const x2 = dotX(c), y2=dotY(r+1);
      const line = document.createElementNS(SVG_NS,'line');
      line.setAttribute('x1',x1); line.setAttribute('y1',y1);
      line.setAttribute('x2',x2); line.setAttribute('y2',y2);
      gridGroup.appendChild(line);
    }
  }

  // ì—£ì§€(ì¸í„°ë™í‹°ë¸Œ): íˆ¬ëª… / inactiveë¡œ ì‹œì‘. í™œì„±í™”ë˜ë©´ í°ìƒ‰ìœ¼ë¡œ ë³´ì„.
  const interactiveGroup = document.createElementNS(SVG_NS,'g');
  interactiveGroup.setAttribute('stroke','#fff');
  interactiveGroup.setAttribute('stroke-width', strokeW);
  interactiveGroup.setAttribute('stroke-linecap','round');
  interactiveGroup.setAttribute('fill','none');
  svg.appendChild(interactiveGroup);

  // ìˆ˜í‰ ì—£ì§€ ìƒì„±
  for(let r=0;r<=N;r++){
    for(let c=0;c<N;c++){
      const key = `h_${r}_${c}`;
      const x1 = dotX(c), y1 = dotY(r);
      const x2 = dotX(c+1), y2 = dotY(r);
      const line = document.createElementNS(SVG_NS,'line');
      line.setAttribute('x1',x1); line.setAttribute('y1',y1);
      line.setAttribute('x2',x2); line.setAttribute('y2',y2);
      line.setAttribute('stroke-opacity', 0); // ì´ˆê¸°ì—” íˆ¬ëª…(ê·¸ë¦¬ë“œëŠ” ì•„ë˜ì— ìˆìŒ)
      line.dataset.key = key;
      line.classList.add('edge');
      interactiveGroup.appendChild(line);
      edges[key] = {el: line, active: false};
    }
  }
  // ìˆ˜ì§ ì—£ì§€ ìƒì„±
  for(let r=0;r<N;r++){
    for(let c=0;c<=N;c++){
      const key = `v_${r}_${c}`;
      const x1 = dotX(c), y1 = dotY(r);
      const x2 = dotX(c), y2 = dotY(r+1);
      const line = document.createElementNS(SVG_NS,'line');
      line.setAttribute('x1',x1); line.setAttribute('y1',y1);
      line.setAttribute('x2',x2); line.setAttribute('y2',y2);
      line.setAttribute('stroke-opacity', 0);
      line.dataset.key = key;
      line.classList.add('edge');
      interactiveGroup.appendChild(line);
      edges[key] = {el: line, active: false};
    }
  }

  // ì (ì‹œê°ì ): ì‘ì€ ì›
  const dotsGroup = document.createElementNS(SVG_NS,'g');
  dotsGroup.setAttribute('fill','#fff');
  svg.appendChild(dotsGroup);
  for(let r=0;r<=N;r++){
    for(let c=0;c<=N;c++){
      const cx = dotX(c), cy = dotY(r);
      const dot = document.createElementNS(SVG_NS,'circle');
      dot.setAttribute('cx', cx);
      dot.setAttribute('cy', cy);
      dot.setAttribute('r', dotRadius);
      dotsGroup.appendChild(dot);
    }
  }

  attachEvents();
}

// ì—£ì§€ í† ê¸€(í™œì„±/ë¹„í™œì„±)
function setEdgeActive(key, on, suppressRender=false){
  const obj = edges[key];
  if(!obj) return;
  obj.active = !!on;
  if(!suppressRender){
    obj.el.setAttribute('stroke-opacity', obj.active ? 1 : 0);
  }
}

// ì „ì²´ ë Œë”(ëª¨ë“  ì—£ì§€)
function renderAll(){
  for(const k in edges){
    edges[k].el.setAttribute('stroke-opacity', edges[k].active ? 1 : 0);
  }
}

// ì—£ì§€ í´ë¦­/ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì—°ê²°
function attachEvents(){
  // ë§ˆìš°ìŠ¤ í•¸ë“¤(í„°ì¹˜ í¬í•¨)
  function onPointerStart(e){
    isMouseDown = true;
    lastToggled = null;
    e.preventDefault();
    const key = findEdgeKeyFromEvent(e);
    if(!key) return;
    // í† ê¸€ ëª¨ë“œ íŒì •: í˜„ì¬ ìƒíƒœ ë°˜ì „
    const current = edges[key].active;
    drawMode = current ? 'off' : 'on';
    toggleEdgeByKey(key, drawMode);
  }
  function onPointerMove(e){
    if(!isMouseDown) return;
    const key = findEdgeKeyFromEvent(e);
    if(!key) return;
    toggleEdgeByKey(key, drawMode);
  }
  function onPointerEnd(e){
    isMouseDown = false;
    drawMode = null;
    lastToggled = null;
  }

  // ì´ë²¤íŠ¸ ë“±ë¡ (pointer API)
  svg.addEventListener('pointerdown', onPointerStart);
  svg.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerEnd);
  // í„°ì¹˜ ì‹œ selection ë°©ì§€
  svg.style.touchAction = 'none';
}

// ì´ë²¤íŠ¸ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì—£ì§€ í‚¤ë¥¼ ê³„ì‚°
function findEdgeKeyFromEvent(evt){
  // clientX/Y -> SVG coordinate
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX; pt.y = evt.clientY;
  const ctm = svg.getScreenCTM().inverse();
  const loc = pt.matrixTransform(ctm);
  // ê° ì—£ì§€ì˜ ì¤‘ì‹¬ì ê³¼ì˜ ê±°ë¦¬ ê³„ì‚°í•´ì„œ ê°€ê¹Œìš´ ì—£ì§€(ì„ê³„ê°’)
  let best = null, bestDist = 99999;
  const threshold = Math.max(cell*0.38, 22); // í„°ì¹˜ ì¹œí™”ì  ë²”ìœ„
  for(const k in edges){
    const el = edges[k].el;
    const x1 = parseFloat(el.getAttribute('x1')), y1 = parseFloat(el.getAttribute('y1'));
    const x2 = parseFloat(el.getAttribute('x2')), y2 = parseFloat(el.getAttribute('y2'));
    // ì¤‘ì 
    const mx = (x1+x2)/2, my = (y1+y2)/2;
    // ê±°ë¦¬ (ìœ í´ë¦¬ë“œ)
    const dx = loc.x - mx, dy = loc.y - my;
    const d = Math.hypot(dx,dy);
    if(d < bestDist){
      bestDist = d; best = k;
    }
  }
  if(bestDist <= threshold) return best;
  return null;
}

function toggleEdgeByKey(key, mode){
  if(!edges[key]) return;
  if(lastToggled === key) return; // ì—°ì† í† ê¸€ ë°©ì§€
  lastToggled = key;
  if(mode === 'on') setEdgeActive(key, true);
  else if(mode === 'off') setEdgeActive(key, false);
  else setEdgeActive(key, !edges[key].active);
}

// ê·¸ë˜í”„ ê²€ì‚¬: í™œì„± ì—£ì§€ë“¤ì´ í•˜ë‚˜ì˜ íë£¨í”„(single cycle)ì¸ì§€ í™•ì¸
function checkSingleCycle(){
  // Build adjacency for nodes (dots). Node index = r*(N+1)+c
  const nodeCount = (N+1)*(N+1);
  const adj = Array.from({length: nodeCount}, ()=>[]);
  let totalEdges = 0;

  for(const key in edges){
    if(!edges[key].active) continue;
    // parse key
    const parts = key.split('_');
    if(parts[0]==='h'){
      const r = parseInt(parts[1]), c = parseInt(parts[2]);
      const a = r*(N+1)+c;
      const b = r*(N+1)+(c+1);
      adj[a].push(b); adj[b].push(a);
      totalEdges++;
    } else if(parts[0]==='v'){
      const r = parseInt(parts[1]), c = parseInt(parts[2]);
      const a = r*(N+1)+c;
      const b = (r+1)*(N+1)+c;
      adj[a].push(b); adj[b].push(a);
      totalEdges++;
    }
  }

  if(totalEdges === 0) return {ok:false, reason:'ì„ ì´ í•˜ë‚˜ë„ ì—†ìŒ'};

  // ê° ì •ì ì˜ ì°¨ìˆ˜ëŠ” 0 ë˜ëŠ” 2 ì´ì–´ì•¼ í•¨. (ë¶„ê¸°(>=3) ë˜ëŠ” ëì (1) => ì‹¤íŒ¨)
  for(let i=0;i<nodeCount;i++){
    const d = adj[i].length;
    if(d !== 0 && d !== 2){
      return {ok:false, reason:`ì •ì ì— ë¶„ê¸° í˜¹ì€ ëì  ë°œìƒ (degree=${d})`};
    }
  }

  // ì—°ê²°ì„± ê²€ì‚¬: í™œì„± ì—£ì§€ê°€ ìˆëŠ” ì •ì ë“¤ë§Œ ê³ ë ¤í•´ì„œ í•˜ë‚˜ì˜ ì—°ê²° ìš”ì†Œì¸ì§€ í™•ì¸
  let start = -1;
  for(let i=0;i<nodeCount;i++) if(adj[i].length>0){ start = i; break; }
  if(start === -1) return {ok:false, reason:'ì„ ì´ ì—†ìŒ'};

  // DFS
  const visited = new Set();
  const stack = [start];
  while(stack.length){
    const u = stack.pop();
    if(visited.has(u)) continue;
    visited.add(u);
    for(const v of adj[u]) if(!visited.has(v)) stack.push(v);
  }

  // í™œì„± ì—£ì§€ì— ì—°ê²°ëœ ì •ì  ìˆ˜
  let nodesInEdges = 0;
  for(let i=0;i<nodeCount;i++) if(adj[i].length>0) nodesInEdges++;

  // For a single simple cycle, number of edges == number of nodes in component
  if(totalEdges !== nodesInEdges){
    return {ok:false, reason:'ë£¨í”„ ìˆ˜ ë˜ëŠ” ì—°ê²°ì„± ë¶ˆì¼ì¹˜ (edges != nodes) â€” ë¶„ë¦¬ëœ ë£¨í”„ê±°ë‚˜ êµì°¨ê°€ ìˆìŒ'};
  }

  // Check visited includes all nodesInEdges
  if(visited.size !== nodesInEdges){
    return {ok:false, reason:'í™œì„± ì—£ì§€ë“¤ì´ í•˜ë‚˜ë¡œ ì—°ê²°ë˜ì–´ ìˆì§€ ì•ŠìŒ'};
  }

  // ìµœì¢…: ëª¨ë“  ì¡°ê±´ ë§Œì¡±
  return {ok:true};
}

// 'ì •ë‹µ í™•ì¸' ë²„íŠ¼ ë™ì‘
checkBtn.addEventListener('click', ()=>{
  const res = checkSingleCycle();
  if(res.ok){
    statusEl.textContent = 'ìƒíƒœ: ì •ë‹µ(ë‹¨ì¼ íë£¨í”„)ì…ë‹ˆë‹¤ ğŸ‰';
  } else {
    statusEl.textContent = 'ìƒíƒœ: í‹€ë¦¼ â€” ' + res.reason;
  }
});

// 'ì§€ìš°ê¸°' ë²„íŠ¼
clearBtn.addEventListener('click', ()=>{
  for(const k in edges) setEdgeActive(k,false);
  renderAll();
  statusEl.textContent = 'ìƒíƒœ: ë³´ë“œ ì´ˆê¸°í™”ë¨';
});

// 'ìƒˆ ê²Œì„' ë²„íŠ¼: ê°„ë‹¨í•œ ëœë¤ ë£¨í”„ ìƒì„±(ì •ë‹µ) ë° ë³´ë“œ ì´ˆê¸°í™”
newBtn.addEventListener('click', ()=>{
  makeRandomSimpleLoop();
  for(const k in edges) setEdgeActive(k,false);
  renderAll();
  statusEl.textContent = 'ìƒíƒœ: ìƒˆ ê²Œì„ (ì •ë‹µì€ ë‚´ë¶€ì— ì„¤ì •ë¨) â€” ì§€ê¸ˆì€ ë³´ì´ì§€ ì•ŠìŠµë‹ˆë‹¤.';
});

// ëœë¤ ë‹¨ìˆœ ë£¨í”„ ìƒì„± í•¨ìˆ˜ (ì‚¬ê°í˜• í˜•íƒœê°€ ì£¼ë¡œ ìƒì„±ë¨) â€” solutionSetì— í‚¤ë¥¼ ë„£ìŒ
function makeRandomSimpleLoop(){
  solutionSet.clear();
  // ì•„ì£¼ ê°„ë‹¨í•œ ì „ëµ: ëœë¤í•œ ë‚´ì¸¡ ì‚¬ê°í˜•ì˜ ë‘˜ë ˆë¥¼ ë£¨í”„ë¡œ ì‚¼ìŒ.
  // ì„ íƒ: top row r1 in [0..N-1], left col c1 in [0..N-1], bottom r2>r1, right c2>c1
  const r1 = randInt(0, Math.max(0,N-3));
  const c1 = randInt(0, Math.max(0,N-3));
  const r2 = randInt(r1+1, Math.min(N-1,N-1));
  const c2 = randInt(c1+1, Math.min(N-1,N-1));
  // ì‚¬ê°í˜• ë‘˜ë ˆ: horizontal top h_r1_c (c1..c2-ê°€ ì•„ë‹Œ? ì£¼ì˜)
  // Our horizontal edges keys h_r_c correspond to top edge of row r cell from col c to c+1
  for(let c=c1;c<=c2-1;c++){
    solutionSet.add(`h_${r1}_${c}`); // top
    solutionSet.add(`h_${r2+1}_${c}`); // bottom (r2's bottom is at r2+1)
  }
  for(let r=r1;r<=r2;r++){
    solutionSet.add(`v_${r}_${c1}`); // left
    solutionSet.add(`v_${r}_${c2+1}`); // right
  }
  // solutionSet now holds keys forming a rectangle loop
  // (ì°¸ê³ : ì¼ë¶€ ëœë¤ ì¡°í•©ì´ ë„ˆë¬´ ì‘ê²Œ ë‚˜ì˜¤ê±°ë‚˜ í…Œë‘ë¦¬ì— ê²¹ì¹  ìˆ˜ ìˆìœ¼ë‚˜ ë‹¨ì¼ ë£¨í”„ë¡œ ìœ ì§€ë©ë‹ˆë‹¤)
  console.log('Solution loop keys (internal):', Array.from(solutionSet).slice(0,40));
}

// ì‘ì€ ìœ í‹¸: ëœë¤ ì •ìˆ˜ inclusive
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// (ì„ íƒ) ë””ë²„ê·¸ìš©: ì •ë‹µ ë³´ì´ê¸° - ì—£ì§€ë¥¼ solutionSetì— í‘œì‹œ (white full). 
// í˜„ì¬ëŠ” ìƒˆ ê²Œì„ì´ ë‚´ë¶€ì ìœ¼ë¡œ solutionSetì„ ë§Œë“¤ì§€ë§Œ ì‚¬ìš©ìì—ê²Œ ë°”ë¡œ í‘œì‹œí•˜ì§€ ì•ŠìŒ.
// ì•„ë˜ ì£¼ì„ì„ í•´ì œí•˜ë©´ 'ìƒˆ ê²Œì„'ì„ ëˆŒë €ì„ ë•Œ ì •ë‹µì„ í™”ë©´ì— í‘œì‹œí•©ë‹ˆë‹¤.
// function revealSolution(){ for(const k of solutionSet) setEdgeActive(k,true); renderAll(); }

// ì´ˆê¸° ë¹Œë“œ ë° ìƒˆ ê²Œì„ í•œ ë²ˆ ìƒì„±
buildBoard();
makeRandomSimpleLoop();
statusEl.textContent = 'ìƒíƒœ: ì¤€ë¹„ â€” ìƒˆ ê²Œì„ì„ ì‹œì‘í•˜ë ¤ë©´ "ìƒˆ ê²Œì„"ì„ ëˆ„ë¥´ì„¸ìš”.';

</script>
</body>
</html>
